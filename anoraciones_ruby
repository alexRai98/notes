irb => para entrar en ruby
.even? => para saber si es par
.odd? => para saber si es impar
.methods => para saber todos los métodos
.class => para saber a qué clase pertenece la variable

#para recibir un valor
	string=gets.chomp
	numero=gets.to_i y así con todos los tipos de datos

#conversiones

	.to_h // para convertir a hash
	.to_a // para convertir a un arreglo o array
	.to_s // para convertir a un string
	.to_i // para convertir a un entero

#numbers
	1.3232.round(#decimales)

#Intermpolación

	nombre = "pepe"
	saludo="Hola #{nombre}"
	saludo=%Q(Hola #{nombre})  // tieme que ser Q mayuscula

#String

	para concatenar se usa el "+"
	se usa * para multiplicar el string
	.capitalize // convierte la primela letra a mayuscula y las demás en minúsculas
	.upcase // poner todo el string en mayúscula
	.downcase // para poner todo en minúscula
	.length // para saber el tamaño del string
	.swpcase // invierte mayúsculas por minusculas y viseversa
	.include? "algo" // para saber si el objeto incluye a "algo"
	.strip // elimina los espacios de los costados del string(formularios)
	.empty? // para saber si está vacío
	.gsub("palab","palabra que reemplazará a palab") // se usa para reemplazar palabras dentro de un string
	.gsub! // el cambio de string, modificará la variable inicial
	.object_id // extrae el id que le da ruby a la variable
	.split(" ") // parte un string por lo que se le diga, en este caso es por espacios 

#symbols =! string 

	ejm => x = :hola  || x_2 = :hola } x y x_2 tienen el mismo id(ruby los reconoce objetos iguales)

#Array
	letra = ["","","",""]// declarar un array
	.size // saber cuantos objetos tiene el array
	.incude? "objeto que se queire saber si se incluye"
	.first // retorna el primer elemento
	.last // reptorna el último elemento
	.count{|x|x=="q"}//pregunta cuantos elementos cumplen con la función entre corchetes --.count{|x|x.even?} también funciona con funciones
	.map{|x| x*2} // aplica los cambios entre {} a cada elemento de un arreglo
	[2,3,4].select{|x| x.odd?} // selecciona los elementos del array que cumplen con la función entre llaves
	.min // selecciona el element más pqueño
	.max // selecciona el ement más grande
	.sum // suma los elemetos del array
	.join("\n") // para unir en este caso un salto de linea
	.compact // elimina los objetos vacios dentro del array
	.[1,2,3,4].each{función} // función ejm => |x| puts "Hola #{x}"
	array << object // para agredar un objeto al array


	ejm => puts("hola mundo".split(" ").map{|x| x.upcase}.join("\n"))
	uotput_: 
		HOLA
		MUNDO
		 => nil
	.sort // para ordenar ("!") para que el orden reemplace al array deshordenado

#Hashes

	{} // para declarar un Hash
	capitales = {"Colombia"=>"Bogota"} // para añadir el primer valor
	capitales["mexico"]="ciudad de mexico" // añadir más valores
	capitales["mexico"] // para obtener el valor relacionado a mexico
	capitales.has_value? "ciudad de mexico" // para saber si el hash contiene a ciudad de mexico
	capitales.has_key? "mexico" // para saber si está la llave mexico
	.invert // invierte valores con llaves
	capitales.merge({"marte"=>"musk"}) // para añadir un nuevo has
	capitales.transform_values{|x| x.downcase} // para transformar las variables dentro del has 
	capitales.map{|k,x|" la capital de #{k} es #{x}"} // para hacer arreglos
	[["pepito",13],["rai",21]].to_h // convertir de array a has

#ciclos
	.while condition do
	end
	.loop do
	 break if condition
	end
	.for i in 1..10 do
	end
	.[1,2,3,4].each{función} // función ejm => |x| puts "Hola #{x}"
	.n.times{función} // times es un método de los enteros y empieza desde el 0 hasta "n"
	
#rangos 
	(1..6)
	("a".."v")
	(1...6) // rango exclusivo(no incluye al 6)
#Procs(procedimiento) y Lambdas

	saluda = Proc.new {|nombre| puts "Hola #{nombre}"} // crea un objeto de la clase Proc
	saluda.call("Rai") // llama al método proc y le pasa un parámetro

	class Transaction
	   def exec // método que reconoce si le da un lambda
	     puts "ejecutando transacción"
	     if block_given? 
	       yield
	       end
	     end
	end

	tx.Transaction.new
	tx.exec{"parámetro"}

